# frozen_string_literal: true

require "fb"
require "active_record/connection_adapters/abstract_adapter"
require "active_record/connection_adapters/firebird/column"
require "active_record/connection_adapters/firebird/database_statements"
require "active_record/connection_adapters/firebird/schema_statements"
require "active_record/connection_adapters/firebird/quoting"
require "active_record/connection_adapters/firebird/schema_definitions"
require "arel/visitors/firebird"
module ActiveRecord
  module ConnectionAdapters
    class FirebirdAdapter < AbstractAdapter
      ADAPTER_NAME = "Firebird"

      include Firebird::DatabaseStatements
      include Firebird::SchemaStatements
      include Firebird::Quoting
      include Firebird::SchemaDefinitions

      def initialize(config)
        super
        @config = config.symbolize_keys
        @config[:database] = build_connection_string(@config)
        @connection = nil
        @firebird_version = nil
      end

      private

      def build_connection_string(config)
        db = config[:database].to_s
        host = config[:host].to_s

        return db if host.empty?
        return db if db.include?(":") || db.start_with?("/")

        "#{host}:#{db}"
      end

      public

      def connect
        return @connection if active?

        @connection = ::Fb::Database.connect(@config)
      end

      def adapter_name
        ADAPTER_NAME
      end

      def firebird_version
        return @firebird_version if @firebird_version

        v = query_value("SELECT RDB$GET_CONTEXT('SYSTEM','ENGINE_VERSION') FROM RDB$DATABASE")
        @firebird_version = if v && v =~ /(\d+)\.(\d+)\.(\d+)/
                              Regexp.last_match(1).to_i * 10_000 +
                                Regexp.last_match(2).to_i * 100 +
                                Regexp.last_match(3).to_i
                            else
                              25_000
                            end
      rescue StandardError
        @firebird_version = 25_000
      end

      def disconnect!
        super
        @connection&.close
        @connection = nil
      end

      def active?
        @connection&.open?
      end

      def reconnect!
        disconnect!
        connect
      end

      def supports_migrations? = true
      def supports_primary_key? = true
      def supports_foreign_keys? = true
      def supports_check_constraints? = true
      def supports_views? = true

      def extract_value_from_default(default)
        case default
        when String
          default
        when nil, /NULL/i
          nil
        else
          default.to_s
        end
      end

      def supports_savepoints? = true
      def supports_transaction_isolation? = true

      def supports_identity_columns?
        firebird_version >= 30_00
      end

      def downcase_columns?
        true
      end

      def supports_insert_returning? = true
      def supports_update_returning? = true
      def supports_delete_returning? = true
      def supports_insert_on_conflict? = false
      def supports_bulk_alter? = false

      def supports_boolean_type?
        firebird_version >= 40_000
      end

      def supports_time_zones?
        firebird_version >= 40_000
      end

      def supports_int128?
        firebird_version >= 40_000
      end

      def supports_skip_locked?
        firebird_version >= 50_000
      end

      def supports_partial_index?
        firebird_version >= 50_000
      end

      def supports_decfloat?
        firebird_version >= 40_000
      end

      def supports_timestamp_with_timezone?
        firebird_version >= 40_000
      end

      def supports_common_table_expressions?
        firebird_version >= 40_000
      end

      def supports_window_functions?
        firebird_version >= 40_000
      end

      def prefers_identity_insert?(_pk = nil)
        true
      end

      def prefetch_primary_key?(_table = nil)
        false
      end

      def arel_visitor
        @arel_visitor ||= Arel::Visitors::Firebird.new(self)
      end

      def write_query?(sql)
        sql = sql.to_s

        !sql.match?(/\A\s*(SELECT|WITH|SHOW|DESCRIBE|EXPLAIN)\b/i)
      end

      def native_database_types
        types = super

        types[:primary_key] = if supports_identity_columns?
                                "BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY"
                              else
                                "BIGINT PRIMARY KEY"
                              end

        # Firebird-specific types (conditional by version)
        types[:boolean] = { name: "BOOLEAN" } if supports_boolean_type?
        types[:decfloat] = { name: "DECFLOAT" } if supports_decfloat?
        types[:time_with_timezone] = { name: "TIME WITH TIME ZONE" } if supports_time_zones?
        types[:timestamp_with_timezone] = { name: "TIMESTAMP WITH TIME ZONE" } if supports_timestamp_with_timezone?
        types[:int128] = { name: "INT128" } if supports_int128?

        # Basic types (always available)
        types[:string] = { name: "VARCHAR", limit: 255 }
        types[:text] = { name: "BLOB SUB_TYPE TEXT" }
        types[:integer] = { name: "INTEGER" }
        types[:bigint] = { name: "BIGINT" }
        types[:float] = { name: "FLOAT" }
        types[:decimal] = { name: "DECIMAL" }
        types[:numeric] = { name: "NUMERIC" }
        types[:datetime] = { name: "TIMESTAMP" }
        types[:timestamp] = { name: "TIMESTAMP" }
        types[:date] = { name: "DATE" }
        types[:time] = { name: "TIME" }
        types[:binary] = { name: "BLOB SUB_TYPE BINARY" }
        types[:json] = { name: "BLOB SUB_TYPE TEXT" }
        types[:uuid] = { name: "CHAR(16) CHARACTER SET OCTETS" }

        types
      end

      def type_to_sql(type, limit: nil, precision: nil, scale: nil, **)
        case type.to_s
        when "integer"
          case limit
          when 1, 2 then "SMALLINT"
          when 3, 4, nil then "INTEGER"
          when 5..8 then "BIGINT"
          else raise ArgumentError, "No integer type has byte size #{limit}"
          end
        when "string"
          "VARCHAR(#{limit || 255})"
        when "text"
          "BLOB SUB_TYPE TEXT"
        when "binary"
          "BLOB SUB_TYPE BINARY"
        when "boolean"
          "BOOLEAN"
        when "decfloat"
          "DECFLOAT"
        when "time"
          "TIME"
        when "datetime", "timestamp"
          "TIMESTAMP"
        when "time_with_timezone"
          "TIME WITH TIME ZONE"
        when "timestamp_with_timezone"
          "TIMESTAMP WITH TIME ZONE"
        when "float"
          "FLOAT"
        when "decimal", "numeric"
          if precision
            if scale
              "NUMERIC(#{precision},#{scale})"
            else
              "NUMERIC(#{precision})"
            end
          else
            "NUMERIC"
          end
        when "date"
          "DATE"
        when "bigint"
          "BIGINT"
        when "int128"
          supports_int128? ? "INT128" : "BIGINT"
        when "timestamptz"
          supports_time_zones? ? "TIMESTAMP WITH TIME ZONE" : "TIMESTAMP"
        when "timetz"
          supports_time_zones? ? "TIME WITH TIME ZONE" : "TIME"
        else
          super
        end
      end
    end
  end
end
