require "spec_helper"

RSpec.describe "Firebird Native Types" do
  let(:connection) { ActiveRecord::Base.connection }

  before(:each) do
    connection.execute("DROP TABLE IF EXISTS test_types_table")
  rescue StandardError
    nil
  end

  after(:each) do
    connection.execute("DROP TABLE IF EXISTS test_types_table")
  rescue StandardError
    nil
  end

  describe "Boolean Type (Firebird 3.0+)" do
    it "supports BOOLEAN columns" do
      skip unless connection.supports_boolean_type?

      connection.execute(<<-SQL)
        CREATE TABLE test_types_table (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          flag BOOLEAN DEFAULT FALSE,
          status BOOLEAN DEFAULT TRUE,
          active BOOLEAN
        )
      SQL

      columns = connection.columns("test_types_table")
      bool_col = columns.find { |c| c.name == "FLAG" }

      expect(bool_col.sql_type).to include("BOOLEAN")
    end
  end

  describe "DECFLOAT Type (Firebird 4.0+)" do
    it "supports DECFLOAT columns with precision" do
      skip unless connection.supports_decfloat?

      connection.execute(<<-SQL)
        CREATE TABLE test_types_table (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          price_decfloat DECFLOAT(16),
          precise_decfloat DECFLOAT(34)
        )
      SQL

      columns = connection.columns("test_types_table")
      price_col = columns.find { |c| c.name == "PRICE_DECFLOAT" }
      precise_col = columns.find { |c| c.name == "PRECISE_DECFLOAT" }

      expect(price_col.sql_type).to include("DECFLOAT(16)")
      expect(precise_col.sql_type).to include("DECFLOAT(34)")
    end
  end

  describe "Time Zone Types (Firebird 4.0+)" do
    it "supports TIME WITH TIME ZONE" do
      skip unless connection.supports_timezones?

      connection.execute(<<-SQL)
        CREATE TABLE test_types_table (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          event_time TIME WITH TIME ZONE,
          log_timestamp TIMESTAMP WITH TIME ZONE
        )
      SQL

      columns = connection.columns("test_types_table")
      time_col = columns.find { |c| c.name == "EVENT_TIME" }
      ts_col = columns.find { |c| c.name == "LOG_TIMESTAMP" }

      expect(time_col.sql_type).to include("TIME WITH TIME ZONE")
      expect(ts_col.sql_type).to include("TIMESTAMP WITH TIME ZONE")
    end
  end

  describe "JSON Support" do
    it "supports JSON via BLOB SUB_TYPE TEXT" do
      connection.execute(<<-SQL)
        CREATE TABLE test_types_table (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          metadata BLOB SUB_TYPE TEXT
        )
      SQL

      columns = connection.columns("test_types_table")
      json_col = columns.find { |c| c.name == "METADATA" }

      expect(json_col.sql_type).to include("BLOB SUB_TYPE TEXT")
    end
  end

  describe "UUID Support" do
    it "supports UUID via CHAR(16) CHARACTER SET OCTETS" do
      connection.execute(<<-SQL)
        CREATE TABLE test_types_table (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          guid CHAR(16) CHARACTER SET OCTETS
        )
      SQL

      columns = connection.columns("test_types_table")
      uuid_col = columns.find { |c| c.name == "GUID" }

      expect(uuid_col.sql_type).to include("CHAR(16)")
    end
  end

  describe "Virtual/Computed Columns" do
    it "supports COMPUTED BY columns" do
      connection.execute(<<-SQL)
        CREATE TABLE test_types_table (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          base_value INTEGER,
          computed_value INTEGER COMPUTED BY (base_value * 2)
        )
      SQL

      columns = connection.columns("test_types_table")
      computed_col = columns.find { |c| c.name == "COMPUTED_VALUE" }

      expect(computed_col.virtual?).to be_truthy
      expect(computed_col.has_default?).to be_falsy
    end
  end
end
